name: Build & Sign macOS Wrapper

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: Release tag (e.g. v1.2.3)
        required: true
      notarize:
        description: Submit to Apple notarization (true/false)
        required: false
        default: "true"
  release:
    types: [published]

jobs:
  build-sign-release:
    runs-on: macos-latest
    env:
      GOPRIVATE: github.com/NeuronInnovations/*
      GH_TOKEN: ${{ secrets.GH_PAT != '' && secrets.GH_PAT || secrets.GITHUB_TOKEN }}
      SIGNING_IDENTITY: ${{ secrets.MAC_SIGNING_IDENTITY }}
      NOTARY_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
      NOTARY_API_ISSUER_ID: ${{ secrets.ASC_API_KEY_ISSUER }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect signing prerequisites
        id: signing-materials
        env:
          ASC_API_KEY: ${{ secrets.ASC_API_KEY }}
          MAC_CERT_P12: ${{ secrets.MAC_CERT_P12 }}
        run: |
          if [ -n "$ASC_API_KEY" ]; then
            echo "has_notary_api_key=true" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "$MAC_CERT_P12" ]; then
            echo "has_mac_cert=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Set release tag
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            echo "RELEASE_TAG=${GITHUB_REF_NAME}" >> "$GITHUB_ENV"
          else
            echo "RELEASE_TAG=${{ github.event.inputs.tag }}" >> "$GITHUB_ENV"
          fi

      - name: Prepare notarization API key
        if: steps.signing-materials.outputs.has_notary_api_key == 'true'
        env:
          ASC_API_KEY: ${{ secrets.ASC_API_KEY }}
        run: |
          KEY_PATH="$RUNNER_TEMP/asc_api_key.p8"
          echo "$ASC_API_KEY" | base64 --decode > "$KEY_PATH"
          chmod 600 "$KEY_PATH"
          echo "NOTARY_API_KEY_PATH=$KEY_PATH" >> "$GITHUB_ENV"

      - name: Configure notarization flag
        env:
          NOTARY_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
          NOTARY_API_ISSUER: ${{ secrets.ASC_API_KEY_ISSUER }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          MAC_CERT_P12: ${{ secrets.MAC_CERT_P12 }}
          MAC_SIGNING_IDENTITY: ${{ secrets.MAC_SIGNING_IDENTITY }}
        run: |
          NOTARIZE_INPUT="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.notarize || 'true' }}"
          NOTARY_API_KEY_PATH=${NOTARY_API_KEY_PATH:-}

          if [ "$NOTARIZE_INPUT" = "false" ]; then
            echo "NOTARIZE=false" >> "$GITHUB_ENV"
          elif [ -n "$NOTARY_API_KEY_PATH" ] && [ -n "$NOTARY_API_KEY_ID" ] && [ -n "$NOTARY_API_ISSUER" ]; then
            echo "NOTARY_API_KEY_PATH=$NOTARY_API_KEY_PATH" >> "$GITHUB_ENV"
            echo "NOTARY_API_KEY_ID=$NOTARY_API_KEY_ID" >> "$GITHUB_ENV"
            echo "NOTARY_API_ISSUER_ID=$NOTARY_API_ISSUER" >> "$GITHUB_ENV"
            echo "NOTARIZE=true" >> "$GITHUB_ENV"
          elif [ -n "$APPLE_ID" ] && [ -n "$APPLE_TEAM_ID" ] && [ -n "$APPLE_APP_SPECIFIC_PASSWORD" ]; then
            echo "NOTARIZE=true" >> "$GITHUB_ENV"
          else
            echo "NOTARIZE=false" >> "$GITHUB_ENV"
            echo "Notarization credentials missing; skipping notarization." >> "$GITHUB_STEP_SUMMARY"
          fi

          if [ -n "$MAC_SIGNING_IDENTITY" ] && [ -z "$MAC_CERT_P12" ]; then
            echo "SIGNING_IDENTITY=" >> "$GITHUB_ENV"
            echo "Signing identity provided without certificate; signing will be skipped." >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache-dependency-path: go.sum

      - name: Capture original keychain state
        run: |
          security list-keychains -d user \
            | tr -d '"' \
            | sed 's/^[[:space:]]*//' \
            > "$RUNNER_TEMP/original_keychains"

          security default-keychain -d user \
            | tr -d '"' \
            | sed 's/^[[:space:]]*//' \
            > "$RUNNER_TEMP/original_default_keychain"
          echo "ORIGINAL_KEYCHAINS_FILE=$RUNNER_TEMP/original_keychains" >> "$GITHUB_ENV"
          echo "ORIGINAL_DEFAULT_KEYCHAIN_FILE=$RUNNER_TEMP/original_default_keychain" >> "$GITHUB_ENV"

      - name: Install signing certificate
        if: steps.signing-materials.outputs.has_mac_cert == 'true'
        env:
          MAC_CERT_P12: ${{ secrets.MAC_CERT_P12 }}
          MAC_CERT_PASSWORD: ${{ secrets.MAC_CERT_PASSWORD }}
          MAC_KEYCHAIN_PASSWORD: ${{ secrets.MAC_KEYCHAIN_PASSWORD }}
        run: |
          set -euo pipefail

          if [ -z "$MAC_CERT_PASSWORD" ]; then
            echo "MAC_CERT_PASSWORD secret is required when MAC_CERT_P12 is provided" >&2
            exit 1
          fi

          if [ -z "$MAC_KEYCHAIN_PASSWORD" ]; then
            echo "MAC_KEYCHAIN_PASSWORD secret is required when MAC_CERT_P12 is provided" >&2
            exit 1
          fi

          KEYCHAIN_NAME="build-signing.keychain-db"
          KEYCHAIN_PATH="$HOME/Library/Keychains/$KEYCHAIN_NAME"

          security create-keychain -p "$MAC_KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$MAC_KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          CERT_P12="$(mktemp "$RUNNER_TEMP/signing-XXXXXX.p12")"
          echo "$MAC_CERT_P12" | base64 --decode > "$CERT_P12"

          TEMP_CERT="$(mktemp "$RUNNER_TEMP/signing-cert-XXXXXX.pem")"
          TEMP_KEY="$(mktemp "$RUNNER_TEMP/signing-key-XXXXXX.pem")"

          if ! openssl pkcs12 -in "$CERT_P12" -clcerts -nokeys -out "$TEMP_CERT" -passin pass:"$MAC_CERT_PASSWORD" -passout pass: 2>/dev/null; then
            echo "Failed to extract certificate from PKCS#12 bundle. Verify MAC_CERT_PASSWORD." >&2
            exit 1
          fi

          if ! openssl pkcs12 -in "$CERT_P12" -nocerts -nodes -out "$TEMP_KEY" -passin pass:"$MAC_CERT_PASSWORD" 2>/dev/null; then
            echo "Failed to extract private key from PKCS#12 bundle. Verify MAC_CERT_PASSWORD." >&2
            exit 1
          fi

          if ! security import "$TEMP_CERT" -k "$KEYCHAIN_PATH" -A 2>/dev/null; then
            echo "Failed to import certificate into keychain" >&2
            exit 1
          fi

          if ! security import "$TEMP_KEY" -k "$KEYCHAIN_PATH" -A -P "" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcrun 2>/dev/null; then
            echo "Failed to import private key into keychain" >&2
            exit 1
          fi

          security set-key-partition-list -S apple-tool:,apple: -s -k "$MAC_KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          EXISTING_KEYCHAINS=()
          while IFS= read -r kc; do
            kc=$(printf '%s' "$kc" | tr -d '"' | sed 's/^[[:space:]]*//')
            if [ -n "$kc" ]; then
              EXISTING_KEYCHAINS+=("$kc")
            fi
          done < <(security list-keychains -d user)

          security list-keychains -d user -s "$KEYCHAIN_PATH" "${EXISTING_KEYCHAINS[@]}"
          security default-keychain -d user -s "$KEYCHAIN_PATH"

          security find-identity -p codesigning "$KEYCHAIN_PATH"

          rm -f "$CERT_P12" "$TEMP_CERT" "$TEMP_KEY"

      - name: Build, sign, and notarize
        run: |
          GOCACHE=$PWD/.gocache GOMODCACHE=$PWD/.gomodcache ./scripts/build-release.sh

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: signed-sdk-wrapper
          path: |
            dist/neuron-wrapper-darwin64
            dist/neuron-wrapper-darwin64.zip
            dist/neuron-wrapper-darwin64.zip.sha256
            dist/neuron-wrapper-darwin64-notary.json
            dist/neuron-wrapper-darwin-arm64
            dist/neuron-wrapper-darwin-arm64.zip
            dist/neuron-wrapper-darwin-arm64.zip.sha256
            dist/neuron-wrapper-darwin-arm64-notary.json
          if-no-files-found: ignore

      - name: Ensure GitHub release exists
        run: |
          set -euo pipefail

          RELEASE_TITLE="Neuron SDK Wrapper ${RELEASE_TAG}"
          RELEASE_NOTES_FILE="$RUNNER_TEMP/release-notes.md"

          if ! gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
            {
              printf '## Neuron SDK Wrapper %s\n\n' "$RELEASE_TAG"
              printf -- '- Universal macOS binaries signed and notarized (Intel & Apple Silicon)\n'
              printf -- '- Includes notarization summary JSON and SHA-256 checksums\n'
            } >"$RELEASE_NOTES_FILE"

            gh release create "$RELEASE_TAG" \
              --title "$RELEASE_TITLE" \
              --notes-file "$RELEASE_NOTES_FILE"
          fi

      - name: Upload assets to release
        run: |
          set -euo pipefail

          gh release upload "$RELEASE_TAG" \
            dist/neuron-wrapper-darwin64 \
            dist/neuron-wrapper-darwin64.zip \
            dist/neuron-wrapper-darwin64.zip.sha256 \
            dist/neuron-wrapper-darwin64-notary.json \
            dist/neuron-wrapper-darwin-arm64 \
            dist/neuron-wrapper-darwin-arm64.zip \
            dist/neuron-wrapper-darwin-arm64.zip.sha256 \
            dist/neuron-wrapper-darwin-arm64-notary.json \
            --clobber

      - name: Cleanup signing materials
        if: always()
        run: |
          set -euo pipefail

          KEYCHAIN_NAME="build-signing.keychain-db"
          KEYCHAIN_PATH="$HOME/Library/Keychains/$KEYCHAIN_NAME"

          if [ -n "${NOTARY_API_KEY_PATH:-}" ] && [ -f "$NOTARY_API_KEY_PATH" ]; then
            rm -f "$NOTARY_API_KEY_PATH"
          fi

          if security list-keychains -d user | tr -d '"' | sed 's/^[[:space:]]*//' | grep -Fq "$KEYCHAIN_NAME"; then
            if [ -f "$KEYCHAIN_PATH" ]; then
              security delete-keychain "$KEYCHAIN_PATH" || true
            else
              security delete-keychain "$KEYCHAIN_NAME" || true
            fi
          fi

          if [ -n "${ORIGINAL_KEYCHAINS_FILE:-}" ] && [ -s "$ORIGINAL_KEYCHAINS_FILE" ]; then
            ORIGINAL_KEYCHAINS=()
            while IFS= read -r kc; do
              kc=$(printf '%s' "$kc" | sed 's/^[[:space:]]*//')
              if [ -n "$kc" ]; then
                ORIGINAL_KEYCHAINS+=("$kc")
              fi
            done < "$ORIGINAL_KEYCHAINS_FILE"

            if [ "${#ORIGINAL_KEYCHAINS[@]}" -gt 0 ]; then
              security list-keychains -d user -s "${ORIGINAL_KEYCHAINS[@]}" || true
            fi
          fi

          if [ -n "${ORIGINAL_DEFAULT_KEYCHAIN_FILE:-}" ] && [ -s "$ORIGINAL_DEFAULT_KEYCHAIN_FILE" ]; then
            ORIGINAL_DEFAULT_KEYCHAIN=$(sed -n '1p' "$ORIGINAL_DEFAULT_KEYCHAIN_FILE")
            if [ -n "$ORIGINAL_DEFAULT_KEYCHAIN" ]; then
              security default-keychain -d user -s "$ORIGINAL_DEFAULT_KEYCHAIN" || true
            fi
          fi

          rm -f "$ORIGINAL_KEYCHAINS_FILE" "$ORIGINAL_DEFAULT_KEYCHAIN_FILE" 2>/dev/null || true
          rm -rf "$RUNNER_TEMP"/asc_api_key.p8 2>/dev/null || true

          if [ -d .gocache ]; then
            chmod -R u+w .gocache 2>/dev/null || true
            rm -rf .gocache 2>/dev/null || true
          fi

          if [ -d .gomodcache ]; then
            chmod -R u+w .gomodcache 2>/dev/null || true
            rm -rf .gomodcache 2>/dev/null || true
          fi
